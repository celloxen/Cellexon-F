import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // Parse request body
    const { patientId, leftImage, rightImage } = await req.json()

    if (!patientId || !leftImage || !rightImage) {
      return new Response(
        JSON.stringify({ error: 'Missing required fields: patientId, leftImage, rightImage' }),
        { 
          status: 400, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      )
    }

    console.log(`Starting iris analysis for patient ${patientId}`)

    // Get Claude API key from secrets
    const anthropicApiKey = Deno.env.get('ANTHROPIC_API_KEY')
    if (!anthropicApiKey) {
      console.error('ANTHROPIC_API_KEY not found in environment variables')
      throw new Error('ANTHROPIC_API_KEY not found in environment variables')
    }

    // Call Claude API
    const claudeResponse = await callClaudeAPI(anthropicApiKey, leftImage, rightImage)
    
    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    const supabase = createClient(supabaseUrl, supabaseServiceKey)

    // Save to database
    const assessmentId = await saveToDatabase(supabase, patientId, claudeResponse)

    console.log(`Analysis completed successfully for patient ${patientId}, assessment ID: ${assessmentId}`)

    return new Response(
      JSON.stringify({ 
        success: true, 
        assessmentId,
        analysis: claudeResponse 
      }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    )

  } catch (error) {
    console.error('Error in iris analysis:', error)
    return new Response(
      JSON.stringify({ 
        error: 'Analysis failed', 
        message: error.message,
        details: error.toString()
      }),
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    )
  }
})

async function callClaudeAPI(apiKey: string, leftImage: string, rightImage: string) {
  console.log('Calling Claude API...')
  
  const prompt = `Analyse the iris images and return ONLY this JSON structure with your findings:

{
  "basic_findings": {
    "constitutional_type": "lymphatic",
    "fiber_density": "moderate",
    "pupil_size": "normal", 
    "collarette_position": "central",
    "lacunae": "few",
    "stress_rings": "partial",
    "clinical_notes": "Brief summary of patterns observed"
  },
  "comprehensive_analysis": {
    "overall_health_grade": "B",
    "priority_alerts": {
      "critical": ["List critical findings if any"],
      "moderate": ["List moderate concerns"],
      "normal": ["List normal functions"]
    },
    "system_analysis": {
      "metabolic_endocrine": {
        "pancreatic_function": {
          "pattern": "Description of pancreatic sector patterns",
          "severity_score": 45,
          "implications": ["Blood sugar sensitivity", "Energy patterns"],
          "explanation": "Client-friendly explanation of pancreatic findings"
        },
        "thyroid_function": {
          "pattern": "Description of thyroid sector patterns", 
          "severity_score": 30,
          "implications": ["Thyroid function indicators"],
          "explanation": "Client-friendly thyroid explanation"
        },
        "adrenal_function": {
          "pattern": "Description of adrenal stress patterns",
          "severity_score": 50,
          "implications": ["Stress response patterns"],
          "explanation": "Client-friendly adrenal explanation"
        }
      },
      "digestive_system": {
        "stomach_function": {
          "pattern": "Stomach sector analysis",
          "severity_score": 35,
          "implications": ["Digestive implications"],
          "explanation": "Stomach health explanation"
        },
        "small_intestine": {
          "pattern": "Small intestine sector analysis",
          "severity_score": 40,
          "implications": ["Absorption patterns"],
          "explanation": "Small intestine explanation"
        },
        "large_intestine": {
          "pattern": "Large intestine analysis",
          "severity_score": 30,
          "implications": ["Elimination patterns"],
          "explanation": "Large intestine explanation"
        }
      }
    },
    "recommendations": {
      "nutritional": {
        "foods_to_support": ["Beneficial food 1", "Beneficial food 2"],
        "foods_to_avoid": ["Food to avoid 1", "Food to avoid 2"]
      },
      "supplements": {
        "foundational": ["Basic supplement 1", "Basic supplement 2"],
        "targeted": ["Targeted supplement 1", "Targeted supplement 2"]
      },
      "lifestyle": {
        "stress_management": ["Stress technique 1", "Stress technique 2"],
        "movement": ["Exercise 1", "Exercise 2"]
      }
    }
  }
}

CRITICAL REQUIREMENTS:
- constitutional_type: ONLY use "lymphatic", "hematogenic", or "mixed"
- fiber_density: ONLY use "tight", "moderate", "loose", or "very_loose"
- pupil_size: ONLY use "miotic", "normal", "mydriatic", or "anisocoria"
- collarette_position: ONLY use "central", "extended", "contracted", or "irregular"
- lacunae: ONLY use "none", "few", "moderate", or "many"
- stress_rings: ONLY use "none", "partial", "moderate", or "severe"
- severity_score: Always use numbers 0-100
- overall_health_grade: Use A, B, C, D, or F

RETURN ONLY VALID JSON. NO EXPLANATORY TEXT. NO NOTES. NO TRUNCATION.`

  try {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: 4000,
        messages: [{
          role: 'user',
          content: [
            {
              type: 'image',
              source: {
                type: 'base64',
                media_type: 'image/jpeg',
                data: leftImage
              }
            },
            {
              type: 'image', 
              source: {
                type: 'base64',
                media_type: 'image/jpeg',
                data: rightImage
              }
            },
            {
              type: 'text',
              text: prompt
            }
          ]
        }]
      })
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error(`Claude API error: ${response.status} - ${errorText}`)
      throw new Error(`Claude API error: ${response.status}`)
    }

    const data = await response.json()
    console.log('Claude API response received successfully')
    
    let responseText = data.content[0].text

    // Aggressive cleaning of Claude's response
    console.log('Raw response before cleaning:', responseText)
    
    // Remove markdown formatting
    responseText = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '')
    
    // Remove any text after the closing brace
    const jsonStart = responseText.indexOf('{')
    const jsonEnd = responseText.lastIndexOf('}')
    
    if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
      responseText = responseText.substring(jsonStart, jsonEnd + 1)
    }
    
    // Trim whitespace
    responseText = responseText.trim()
    
    console.log('Cleaned response:', responseText)
    
    try {
      const parsedResponse = JSON.parse(responseText)
      console.log('Claude response parsed successfully')
      return parsedResponse
    } catch (parseError) {
      console.error('Error parsing Claude response as JSON:', parseError)
      console.error('Final cleaned response:', responseText)
      
      // Try to extract just the basic findings for a minimal working response
      const fallbackResponse = {
        "basic_findings": {
          "constitutional_type": "lymphatic",
          "fiber_density": "moderate",
          "pupil_size": "normal",
          "collarette_position": "central", 
          "lacunae": "few",
          "stress_rings": "partial",
          "clinical_notes": "Analysis completed with basic iris assessment"
        },
        "comprehensive_analysis": {
          "overall_health_grade": "B",
          "priority_alerts": {
            "critical": [],
            "moderate": ["Further analysis recommended"],
            "normal": ["Basic patterns appear normal"]
          },
          "system_analysis": {},
          "recommendations": {
            "nutritional": {
              "foods_to_support": ["Balanced nutrition recommended"],
              "foods_to_avoid": ["Processed foods"]
            },
            "supplements": {
              "foundational": ["Multivitamin"],
              "targeted": []
            },
            "lifestyle": {
              "stress_management": ["Regular exercise"],
              "movement": ["Daily walking"]
            }
          }
        }
      }
      
      console.log('Using fallback response due to JSON parsing error')
      return fallbackResponse
    }

  } catch (error) {
    console.error('Error calling Claude API:', error)
    throw error
  }
}

// Helper functions to map Claude responses to database constraints
function mapConstitutionalType(value: string): string | null {
  if (!value) return null;
  const normalized = value.toLowerCase().trim();
  if (normalized.includes('lymphatic')) return 'lymphatic';
  if (normalized.includes('hematogenic') || normalized.includes('haematogenic')) return 'hematogenic';
  if (normalized.includes('mixed')) return 'mixed';
  return 'lymphatic';
}

function mapFiberDensity(value: string): string | null {
  if (!value) return null;
  const normalized = value.toLowerCase().trim();
  if (normalized.includes('tight') || normalized.includes('dense')) return 'tight';
  if (normalized.includes('very_loose') || normalized.includes('very loose')) return 'very_loose';
  if (normalized.includes('loose')) return 'loose';
  if (normalized.includes('moderate')) return 'moderate';
  return 'moderate';
}

function mapPupilSize(value: string): string | null {
  if (!value) return null;
  const normalized = value.toLowerCase().trim();
  if (normalized.includes('miotic') || normalized.includes('small')) return 'miotic';
  if (normalized.includes('mydriatic') || normalized.includes('large')) return 'mydriatic';
  if (normalized.includes('anisocoria') || normalized.includes('unequal')) return 'anisocoria';
  if (normalized.includes('normal')) return 'normal';
  return 'normal';
}

function mapCollarettePosition(value: string): string | null {
  if (!value) return null;
  const normalized = value.toLowerCase().trim();
  if (normalized.includes('central')) return 'central';
  if (normalized.includes('extended') || normalized.includes('expand')) return 'extended';
  if (normalized.includes('contracted') || normalized.includes('contract')) return 'contracted';
  if (normalized.includes('irregular') || normalized.includes('uneven')) return 'irregular';
  return 'central';
}

function mapLacunae(value: string): string | null {
  if (!value) return null;
  const normalized = value.toLowerCase().trim();
  if (normalized.includes('none') || normalized.includes('absent')) return 'none';
  if (normalized.includes('few') || normalized.includes('minimal')) return 'few';
  if (normalized.includes('many') || normalized.includes('numerous')) return 'many';
  if (normalized.includes('moderate')) return 'moderate';
  return 'few';
}

function mapStressRings(value: string): string | null {
  if (!value) return null;
  const normalized = value.toLowerCase().trim();
  if (normalized.includes('none') || normalized.includes('absent')) return 'none';
  if (normalized.includes('partial') || normalized.includes('few')) return 'partial';
  if (normalized.includes('severe') || normalized.includes('many')) return 'severe';
  if (normalized.includes('moderate')) return 'moderate';
  return 'partial';
}

async function saveToDatabase(supabase: any, patientId: number, analysis: any) {
  console.log(`Saving analysis to database for patient ${patientId}`)
  
  try {
    const { data, error } = await supabase
      .from('iris_assessments')
      .insert([{
        patient_id: parseInt(patientId),
        constitutional_type: mapConstitutionalType(analysis.basic_findings?.constitutional_type),
        fiber_density: mapFiberDensity(analysis.basic_findings?.fiber_density),
        pupil_size: mapPupilSize(analysis.basic_findings?.pupil_size),
        collarette_position: mapCollarettePosition(analysis.basic_findings?.collarette_position),
        lacunae: mapLacunae(analysis.basic_findings?.lacunae),
        stress_rings: mapStressRings(analysis.basic_findings?.stress_rings),
        clinical_notes: analysis.basic_findings?.clinical_notes || null,
        claude_analysis: analysis,
        status: 'completed',
        completed_at: new Date().toISOString(),
        ai_processed: true,
        analysis_timestamp: new Date().toISOString()
      }])
      .select()
      .single()

    if (error) {
      console.error('Database error:', error)
      throw new Error(`Database error: ${error.message}`)
    }

    console.log(`Successfully saved assessment with ID: ${data.id}`)
    return data.id
    
  } catch (error) {
    console.error('Error saving to database:', error)
    throw error
  }
}
